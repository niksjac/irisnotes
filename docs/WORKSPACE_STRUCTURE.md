# IrisNotes Workspace Structure

Complete guide to the IrisNotes project structure, file organization, and directory purposes.

## Overview

IrisNotes is a monorepo containing a Tauri desktop application with a React frontend. The project follows a clear separation between frontend (TypeScript/React), backend (Rust/Tauri), tooling, and configuration.

---

## Root Directory Structure

```
irisnotes/
├── dev/                      # Development tools & artifacts
├── docs/                     # Project documentation
├── public/                   # Static assets
├── schema/                   # Database schema (SQLite)
├── scripts/                  # Build & utility scripts
├── src/                      # Frontend source code (React/TS)
├── src-tauri/                # Backend source code (Rust/Tauri)
├── biome.json                # Biome linter/formatter config
├── index.html                # HTML entry point
├── package.json              # Node.js dependencies & scripts
├── pnpm-lock.yaml            # Lockfile for pnpm
├── tsconfig.json             # TypeScript configuration
├── tsconfig.node.json        # TypeScript config for Node tools
├── vite.config.ts            # Vite bundler configuration
├── CLOUD_SYNC_ROADMAP.txt    # Feature roadmap
└── HOTKEYS.md                # Keyboard shortcuts reference
```

---

## `/dev` - Development Tools & Artifacts

Development-specific files not included in production builds.

```
dev/
├── config.json               # Runtime config (app state)
├── hotkeys.json              # Hotkey bindings
├── hotkeys-template.json     # Default hotkey template
├── notes.db                  # Development SQLite database
├── setup-dev-db.sh           # Database initialization script
└── storage.json              # Storage adapter state
```

### Key Files

#### `notes.db`
- **Purpose**: Development SQLite database
- **Generated by**: `./dev/setup-dev-db.sh`
- **Gitignored**: Yes (not committed)
- **Schema**: Defined in `/schema/base.sql`

#### `setup-dev-db.sh`
```bash
#!/bin/bash
# Creates fresh dev database from schema + seed data
rm -f dev/notes.db
sqlite3 dev/notes.db < schema/base.sql
sqlite3 dev/notes.db < schema/seed-dev.sql
```

**Usage**: Run after schema changes or fresh checkout.

#### `config.json`
Application runtime configuration:
```json
{
  "theme": "dark",
  "editorMode": "rich",
  "lastOpenNote": "note-123"
}
```

#### `hotkeys.json`
Custom keyboard shortcuts:
```json
{
  "search": "CommandOrControl+K",
  "newNote": "CommandOrControl+N",
  "toggleEditor": "CommandOrControl+E"
}
```

#### `storage.json`
Storage adapter state (used by development storage adapter):
```json
{
  "items": [...],
  "tags": [...]
}
```

---

## `/docs` - Project Documentation

Comprehensive markdown documentation (created in this session!).

```
docs/
├── CLI_TOOL.md               # CLI feature specifications
├── QUICK_SEARCH.md           # Quick search overlay design
├── DATABASE_DESIGN.md        # Database schema documentation
└── WORKSPACE_STRUCTURE.md    # This file
```

---

## `/public` - Static Assets

Files served directly without processing.

```
public/
└── chatgpt-generated-images/ # AI-generated assets
```

**Accessed via**: `/` in the app (e.g., `/logo.png` → `public/logo.png`)

---

## `/schema` - Database Schema

The **single source of truth** for database structure.

```
schema/
├── base.sql                  # Complete schema definition
└── seed-dev.sql              # Sample data for development
```

### `base.sql`
Contains:
- Table definitions (`items`, `tags`, `item_tags`, `item_revisions`, `settings`)
- Indexes for performance
- Triggers (FTS sync, timestamps, version history)
- Views (`tree_items`, `hierarchy_check`, `note_revisions`)
- Full-text search virtual table (`items_fts`)

**Critical**: All schema changes must go here, then regenerate DB.

### `seed-dev.sql`
Sample data:
- 3 books (Personal, Work, Reading List)
- 6 sections
- 12 notes with realistic content

**Purpose**: Provides test data for development.

---

## `/scripts` - Utility Scripts

Build automation and development tooling.

```
scripts/
├── check.sh                  # Run type checks & linting
├── setup-dev-config.sh       # Initialize dev config files
├── smart-biome-toggle.sh     # Toggle Biome formatting
├── toggle-biome-config.sh    # Enable/disable Biome
├── toggle-format.sh          # Toggle formatting on/off
└── toggle-linewidth.sh       # Toggle line width settings
```

### Key Scripts

#### `check.sh`
```bash
#!/bin/bash
pnpm run type-check
pnpm run biome:check
```
**Usage**: CI/CD pipeline, pre-commit hooks.

#### `setup-dev-config.sh`
Initializes development environment:
- Creates `dev/config.json` if missing
- Copies `dev/hotkeys-template.json` → `dev/hotkeys.json`
- Sets up storage adapter files

#### `toggle-biome-*.sh`
Development convenience scripts for switching linter/formatter settings during AI pair programming sessions.

---

## `/src` - Frontend Source Code

React 19 + TypeScript application.

```
src/
├── atoms/                    # Jotai state management
├── components/               # React components
├── config/                   # Configuration constants
├── hooks/                    # Custom React hooks
├── storage/                  # Storage adapters & types
├── styles/                   # Global CSS
├── types/                    # TypeScript type definitions
├── utils/                    # Pure utility functions
├── views/                    # Top-level view components
├── app.tsx                   # Root app component
├── layout.tsx                # Main layout component
├── main.tsx                  # Application entry point
├── view.tsx                  # View router component
└── vite-env.d.ts             # Vite type declarations
```

### Directory Details

#### `/src/atoms` - State Management (Jotai)

```
atoms/
├── actions.ts                # Action creators
├── index.ts                  # Legacy atoms (compatibility)
├── items.ts                  # Main data atoms (unified items)
├── panes.ts                  # Multi-pane layout state
└── tree.ts                   # Tree view state
```

**Pattern**: Each file exports related atoms and derived atoms.

**Example**:
```typescript
// atoms/items.ts
export const itemsAtom = atom<Item[]>([]);
export const selectedItemIdAtom = atom<string | null>(null);
export const selectedItemAtom = atom((get) => {
  const items = get(itemsAtom);
  const id = get(selectedItemIdAtom);
  return items.find(i => i.id === id);
});
```

#### `/src/components` - React Components

Organized by UI area:

```
components/
├── activity-bar/             # Left sidebar icons
│   ├── activity-bar-button.tsx
│   ├── activity-bar.tsx
│   └── storage-adapter-button.tsx
├── editor/                   # Editor container
│   └── editor-container.tsx
├── panes/                    # Multi-pane system
│   ├── pane-container.tsx
│   ├── pane-resizer.tsx
│   └── pane.tsx
├── right-click-menu/         # Context menus
│   └── right-click-menu.tsx
├── sidebar/                  # Left sidebar (tree view)
│   ├── sidebar-resizer.tsx
│   └── sidebar.tsx
├── tabs/                     # Tab management
├── tree/                     # Tree view components
└── index.ts                  # Barrel exports
```

**Convention**: Each feature has its own subdirectory.

#### `/src/config` - Configuration Constants

```
config/
└── default-hotkeys.ts        # Default keyboard shortcuts
```

**Purpose**: Hardcoded configuration values.

#### `/src/hooks` - Custom React Hooks

Business logic abstracted from components:

```
hooks/
├── use-app-hotkeys.ts        # Global hotkey registration
├── use-app-info.ts           # App version, platform info
├── use-app-persistence.ts    # Save/load app state
├── use-config.ts             # Configuration management
├── use-editor-layout.ts      # Editor pane layout
├── use-editor-state.ts       # Editor mode & state
├── use-hotkey-handlers.ts    # Hotkey action handlers
├── use-hotkeys-config.ts     # Hotkey configuration
├── use-items.ts              # Items CRUD operations
├── use-layout-persistence.ts # Save/restore layout
├── use-layout.ts             # Layout management
├── use-line-wrapping.ts      # Editor line wrapping
├── use-media-query.ts        # Responsive breakpoints
├── use-notes-handlers.ts     # Note operation handlers
├── use-notes-storage.ts      # Storage abstraction
├── use-performance.ts        # Performance monitoring
├── use-right-click-menu-actions.ts  # Context menu actions
├── use-right-click-menu.ts   # Context menu state
├── use-sidebar.ts            # Sidebar state
├── use-tab-management.ts     # Tab operations
├── use-theme.ts              # Dark/light theme
├── use-tree-view.ts          # Tree view logic
├── use-view.ts               # View routing
└── index.ts                  # Barrel exports
```

**Pattern**: Hooks encapsulate complex logic for reusability.

#### `/src/storage` - Storage Abstraction

Database access layer with multiple adapters:

```
storage/
├── adapters/                 # Storage implementations
│   ├── json-single.ts        # JSON file adapter (dev)
│   └── sqlite.ts             # SQLite adapter (production)
├── schema/                   # Type-safe schema helpers
├── factory.ts                # Adapter factory
├── hierarchy.ts              # Hierarchy utilities
├── index.ts                  # Barrel exports
└── types.ts                  # Storage interface types
```

**Key Files**:

- **`factory.ts`**: Chooses adapter based on environment
- **`types.ts`**: Defines `StorageAdapter` interface
- **`adapters/sqlite.ts`**: Tauri SQL plugin integration
- **`adapters/json-single.ts`**: Fallback for development

**Pattern**: Adapter pattern for swappable storage backends.

#### `/src/styles` - Global CSS

```
styles/
├── tailwind.css              # Tailwind imports
└── theme.css                 # Custom CSS variables
```

**`theme.css`** defines:
- CSS custom properties for colors
- Dark/light theme variables
- Global styles

#### `/src/types` - TypeScript Definitions

```
types/
├── database.ts               # Database entity types
├── index.ts                  # Shared types
├── items.ts                  # Item model types
└── right-click-menu.ts       # Context menu types
```

**Pattern**: Separate files for domain concepts.

**Example**:
```typescript
// types/items.ts
export type ItemType = 'note' | 'book' | 'section';

export interface Item {
  id: string;
  type: ItemType;
  title: string;
  content?: string;
  parent_id?: string | null;
  sort_order: number;
  metadata: Record<string, unknown>;
  created_at: string;
  updated_at: string;
}
```

#### `/src/utils` - Pure Utility Functions

```
utils/
├── hotkey-mapping.ts         # Hotkey normalization
└── hotkey-template.ts        # Hotkey template generation
```

**Rule**: Only pure functions (no side effects).

#### `/src/views` - Top-Level View Components

Main content area views:

```
views/
├── config-view.tsx           # Settings panel
├── editor-rich-view.tsx      # ProseMirror rich editor
├── editor-source-view.tsx    # CodeMirror source editor
├── empty-view.tsx            # No selection state
├── hotkeys-view.tsx          # Keyboard shortcuts panel
└── index.ts                  # Barrel exports
```

**Routing**: Switched based on selected item type and view mode.

---

## `/src-tauri` - Backend (Rust)

Tauri application backend (Rust).

```
src-tauri/
├── src/
│   ├── lib.rs                # Library entry point
│   └── main.rs               # Application entry point
├── capabilities/
│   └── default.json          # Permission manifest
├── gen/
│   └── schemas/              # Generated type schemas
├── icons/                    # Application icons
├── target/                   # Rust build artifacts (gitignored)
│   ├── debug/
│   └── release/
├── build.rs                  # Build script
├── Cargo.toml                # Rust dependencies
└── tauri.conf.json           # Tauri configuration
```

### Key Files

#### `src/main.rs`
Application entry point:
```rust
#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_sql::Builder::default().build())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_global_shortcut::Builder::new().build())
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

#### `src/lib.rs`
Exports Tauri commands (API for frontend):
```rust
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}
```

#### `tauri.conf.json`
Tauri configuration:
- Window settings
- Plugins
- Permissions
- Build settings
- Auto-updater config

#### `Cargo.toml`
Rust dependencies:
```toml
[dependencies]
tauri = { version = "2.0", features = ["..."] }
tauri-plugin-sql = "2.0"
tauri-plugin-fs = "2.0"
serde = { version = "1.0", features = ["derive"] }
```

#### `/capabilities/default.json`
Security permissions for Tauri:
```json
{
  "permissions": [
    "core:default",
    "sql:default",
    "fs:default"
  ]
}
```

---

## Configuration Files (Root)

### `package.json`
Node.js project configuration:

```json
{
  "name": "irisnotes",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "tauri": "tauri",
    "tauri:dev": "tauri dev",
    "type-check": "tsc --noEmit",
    "biome:check": "biome check .",
    "biome:fix": "biome check --write ."
  },
  "dependencies": {
    "react": "^19.0.0",
    "jotai": "^2.0.0",
    "@tauri-apps/api": "^2.0.0"
  }
}
```

**Key Scripts**:
- `pnpm tauri dev` - Start development server
- `pnpm tauri build` - Production build
- `pnpm type-check` - TypeScript validation
- `pnpm biome:fix` - Auto-fix linting

### `biome.json`
Biome linter/formatter configuration:

```json
{
  "formatter": {
    "lineWidth": 80,
    "indentStyle": "space"
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true
    }
  }
}
```

**Used by**: VS Code extension, CI/CD.

### `tsconfig.json`
TypeScript compiler configuration:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "jsx": "react-jsx",
    "strict": true,
    "moduleResolution": "bundler"
  }
}
```

**Mode**: Strict type checking enabled.

### `vite.config.ts`
Vite bundler configuration:

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  clearScreen: false,
  server: {
    port: 1420,
    strictPort: true
  }
});
```

**Port**: Frontend runs on `localhost:1420` in dev mode.

---

## File Naming Conventions

### TypeScript/JavaScript
- **Components**: `kebab-case.tsx` (e.g., `sidebar-resizer.tsx`)
- **Hooks**: `use-*.ts` (e.g., `use-theme.ts`)
- **Types**: `kebab-case.ts` (e.g., `right-click-menu.ts`)
- **Utils**: `kebab-case.ts` (e.g., `hotkey-mapping.ts`)

### Rust
- **Modules**: `snake_case.rs` (e.g., `main.rs`)
- **Config**: `kebab-case.json` (e.g., `tauri.conf.json`)

### SQL
- **Schema**: `kebab-case.sql` (e.g., `base.sql`)
- **Seeds**: `kebab-case.sql` (e.g., `seed-dev.sql`)

### Scripts
- **Shell**: `kebab-case.sh` (e.g., `setup-dev-db.sh`)

---

## Development Workflow

### 1. Initial Setup
```bash
# Install dependencies
pnpm install

# Setup development database
./dev/setup-dev-db.sh

# Setup config files (if needed)
./scripts/setup-dev-config.sh
```

### 2. Development
```bash
# Start Tauri dev server (hot reload enabled)
pnpm tauri dev

# Type checking (separate terminal)
pnpm type-check --watch

# Linting
pnpm biome:check
```

### 3. Building
```bash
# Production build
pnpm tauri build

# Output: src-tauri/target/release/bundle/
```

### 4. Database Changes
```bash
# 1. Edit schema/base.sql
# 2. Regenerate dev database
./dev/setup-dev-db.sh

# 3. Update TypeScript types
# Edit src/types/database.ts
```

---

## Gitignore Strategy

### What's Committed
- Source code (`/src`, `/src-tauri/src`)
- Configuration templates
- Schema definitions
- Scripts
- Documentation

### What's Ignored
- `node_modules/` - npm packages
- `src-tauri/target/` - Rust build artifacts
- `dev/notes.db` - Development database
- `dev/config.json` - User config
- `dev/storage.json` - Runtime state
- `dist/` - Build output

---

## Build Artifacts

### Development
```
dev/notes.db              # SQLite database
node_modules/             # npm packages
src-tauri/target/debug/   # Rust debug build
```

### Production
```
dist/                     # Vite frontend build
src-tauri/target/release/ # Rust release build
src-tauri/target/release/bundle/  # Platform packages
  ├── appimage/           # Linux AppImage
  ├── deb/                # Debian package
  ├── dmg/                # macOS disk image
  └── msi/                # Windows installer
```

---

## Dependencies

### Frontend (package.json)
- **React 19**: UI framework
- **Jotai**: State management
- **Tailwind CSS**: Styling
- **CodeMirror 6**: Source editor
- **ProseMirror**: Rich text editor
- **@tauri-apps/api**: Tauri JavaScript API
- **@tauri-apps/plugin-*****: Tauri plugins

### Backend (Cargo.toml)
- **tauri**: Desktop app framework
- **tauri-plugin-sql**: SQLite integration
- **tauri-plugin-fs**: File system access
- **tauri-plugin-global-shortcut**: Hotkeys
- **serde**: Serialization
- **rusqlite**: SQLite bindings

---

## Environment Variables

```bash
# Development
TAURI_DEV_WATCHER=true    # Enable file watcher
RUST_LOG=debug            # Rust logging level

# Build
TAURI_PRIVATE_KEY=...     # For code signing
TAURI_KEY_PASSWORD=...    # Key password
```

---

## IDE Setup (VS Code)

Recommended extensions:
- **Biome**: Linting/formatting
- **Tauri**: Tauri development
- **rust-analyzer**: Rust language server
- **Tailwind CSS IntelliSense**: Tailwind autocomplete

**Settings**:
```json
{
  "editor.defaultFormatter": "biomejs.biome",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "quickfix.biome": "explicit"
  }
}
```

---

## Future Structure Additions

As the project grows, consider:

```
irisnotes/
├── packages/             # Monorepo packages
│   ├── shared/           # Shared types/utils
│   ├── cli/              # CLI tool
│   └── quick/            # Quick search app
├── tests/                # E2E tests
│   ├── e2e/
│   ├── integration/
│   └── unit/
└── .github/
    └── workflows/        # CI/CD pipelines
```

---

## Common Tasks Reference

### Add New Component
```bash
# 1. Create file
touch src/components/my-feature/my-component.tsx

# 2. Export from index
echo "export * from './my-component';" >> src/components/my-feature/index.ts

# 3. Use in parent
import { MyComponent } from '@/components/my-feature';
```

### Add New Atom
```typescript
// src/atoms/my-feature.ts
import { atom } from 'jotai';

export const myFeatureAtom = atom<MyFeatureState>({
  // initial state
});
```

### Add New Tauri Command
```rust
// src-tauri/src/lib.rs
#[tauri::command]
fn my_command(arg: String) -> Result<String, String> {
    Ok(format!("Result: {}", arg))
}

// Register in main.rs
.invoke_handler(tauri::generate_handler![my_command])
```

### Add Database Migration
```sql
-- schema/base.sql
ALTER TABLE items ADD COLUMN new_field TEXT DEFAULT '';

-- Then regenerate:
./dev/setup-dev-db.sh
```

---

## Troubleshooting

### Database Locked
```bash
# Close main app, then:
rm dev/notes.db
./dev/setup-dev-db.sh
```

### Type Errors After Schema Change
```bash
# Regenerate types
pnpm type-check
# Update src/types/database.ts manually
```

### Tauri Build Fails
```bash
# Clean and rebuild
cd src-tauri
cargo clean
cd ..
pnpm tauri build
```

### Vite Port Conflict
```bash
# Change port in vite.config.ts
server: {
  port: 1421,  // different port
  strictPort: true
}
```

---

This completes the workspace structure documentation!
