# Fractional Indexing for Sort Order

IrisNotes uses **fractional indexing** for item ordering, enabling sync-safe reordering without conflicts.

## Overview

Instead of integer sort orders (0, 1, 2, 3...), we use lexicographically sortable strings generated by the [`fractional-indexing`](https://www.npmjs.com/package/fractional-indexing) library.

### Why Fractional Indexing?

**Problem with integers:**
- Two devices insert at position 2 → both get `sort_order = 2` → conflict!
- Rebalancing required when inserting between items
- Gaps fill up over time

**Solution with fractional indexing:**
- Insert between `a0` and `a1` → generate `a0V` (always unique)
- No rebalancing needed
- Infinite insertions possible between any two items
- Sync-safe: concurrent inserts at same position get different keys

## Implementation Details

### Key Generation

```typescript
import { generateKeyBetween } from "fractional-indexing";

// First item
generateKeyBetween(null, null);     // → "a0"

// After "a0"
generateKeyBetween("a0", null);     // → "a1"

// Before "a0"  
generateKeyBetween(null, "a0");     // → "Zz"

// Between "a0" and "a1"
generateKeyBetween("a0", "a1");     // → "a0V"
```

### Character Set

The library uses base-62 encoding: `0-9` < `A-Z` < `a-z`

**Critical:** Keys must be compared using ASCII order, NOT `localeCompare()`:

```typescript
// ❌ WRONG - localeCompare treats uppercase after lowercase
"Zz".localeCompare("a0")  // → 1 (incorrect: Zz appears after a0)

// ✅ CORRECT - ASCII comparison
"Zz" < "a0"               // → true (correct: Zz appears before a0)
```

### Sort Comparison Utility

We provide a utility function in `src/utils/sort-order.ts`:

```typescript
export function compareSortOrder(a: string, b: string): number {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}
```

Usage:
```typescript
items.sort((a, b) => compareSortOrder(a.sort_order, b.sort_order));
```

## Database Schema

```sql
-- sort_order is TEXT, not INTEGER
sort_order TEXT NOT NULL DEFAULT 'a0'
```

## TypeScript Types

```typescript
// In src/types/items.ts
interface FlexibleItem {
  // ...
  sort_order: string;  // Fractional index string
}
```

## Files Modified

### Core Implementation
- `src/utils/sort-order.ts` - Sort comparison utility
- `src/types/items.ts` - Type definition (`sort_order: string`)
- `src/types/database.ts` - Legacy Note type (`sort_order: string`)
- `src/types/index.ts` - TreeData type (`sort_order: string`)
- `schema/base.sql` - Database schema (`sort_order TEXT`)

### Storage Adapters
- `src/storage/adapters/sqlite-adapter.ts` - `getNextSortOrder()`, `moveTreeItem()`
- `src/storage/adapters/json-single-adapter.ts` - Same methods
- `src/storage/adapters/json-hybrid-adapter.ts` - Same methods

### UI Components
- `src/atoms/items.ts` - Tree grouping sort
- `src/components/tree/tree-view.tsx` - Children map and root items sort
- `src/hooks/use-tab-management.ts` - Tab ordering

## Common Operations

### Moving an Item

```typescript
async moveTreeItem(itemId, newParentId, insertIndex) {
  // Get siblings at target (excluding the item being moved)
  const siblings = await getSiblings(newParentId, excludeId: itemId);
  
  let newSortOrder: string;
  
  if (siblings.length === 0) {
    // First item in parent
    newSortOrder = generateKeyBetween(null, null);
  } else if (insertIndex === 0) {
    // Insert at beginning
    newSortOrder = generateKeyBetween(null, siblings[0].sort_order);
  } else if (insertIndex >= siblings.length) {
    // Append at end
    newSortOrder = generateKeyBetween(siblings[siblings.length - 1].sort_order, null);
  } else {
    // Insert between two items
    const before = siblings[insertIndex - 1].sort_order;
    const after = siblings[insertIndex].sort_order;
    newSortOrder = generateKeyBetween(before, after);
  }
  
  await updateItem(itemId, { sort_order: newSortOrder });
}
```

### Creating a New Item

```typescript
async createItem(params) {
  const siblings = await getSiblings(params.parent_id);
  
  // New items go at the end
  const lastKey = siblings.length > 0 
    ? siblings.sort((a, b) => b.sort_order < a.sort_order ? -1 : 1)[0].sort_order
    : null;
  
  const sort_order = generateKeyBetween(lastKey, null);
  
  return await insertItem({ ...params, sort_order });
}
```

## Edge Cases

### Key Exhaustion

In theory, you could exhaust keys between two adjacent values. In practice:
- The library handles this by generating longer keys
- Real-world usage rarely creates deep nesting
- If needed, a batch rebalance can regenerate all keys

### Collisions During Sync

Fractional indexing minimizes but doesn't eliminate all conflicts:
- Same position inserts on different devices get different keys
- If identical keys somehow occur, use secondary sort (e.g., `created_at`)

## References

- [fractional-indexing npm package](https://www.npmjs.com/package/fractional-indexing)
- [Implementing Fractional Indexing](https://www.figma.com/blog/realtime-editing-of-ordered-sequences/) - Figma's blog post
- [CRDT literature on ordered sequences](https://crdt.tech/)
